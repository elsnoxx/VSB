// ***********************************************************************
//
// DEMO PROGRAM FOR EDUCATION IN SUBJECT
// COMPUTER ARCHITECTURES AND PARALLEL SYSTEMS
// PETR OLIVKA, DEP. OF COMPUTER SCIENCE, FEI, VSB-TU OSTRAVA, 2020/11
// EMAIL:PETR.OLIVKA@VSB.CZ
//
// EXAMPLE OF CUDA TECHNOLOGY USAGE WITH UNIFIED MEMORY.
//
// MULTIPLICATION OF ELEMENTS IN FLOAT ARRAY.
//
// ***********************************************************************

#INCLUDE <STDIO.H>
#INCLUDE <MATH.H>
#INCLUDE <CUDA_DEVICE_RUNTIME_API.H>
#INCLUDE <CUDA_RUNTIME.H>
#INCLUDE <IOSTREAM>
#INCLUDE <CSTDIO>
#INCLUDE <STRING>
#INCLUDE <TYPEINFO>

// FUNCTION PROTOTYPE FROM .CU FILE
VOID CU_RUN_SUM( FLOAT *T_ARRAY, FLOAT *T_ARRAY2, FLOAT *RESULT, INT T_LENGTH, FLOAT T_MULT );
VOID CU_RUN_PREVOD(CHAR *BUFFER, LONG T_LENGTH);
VOID CU_RUN_MATICE(DOUBLE *MATICEA,DOUBLE *MATICEB,DOUBLE *MATICEC, INT T_LENGTH);


VOID PRINTARRAY(FLOAT *L_ARRAY, INT N){
    FOR ( INT I = 0; I < N; I++ )
        PRINTF( "%8.2F", L_ARRAY[ I ] );
    PRINTF( "\N" );

}

VOID CHECKARRAY(FLOAT *L_ARRAY, FLOAT *L_ARRAY2, INT N)
{
   INT KONEC = 0;
   FOR (INT I = 0; I < N; I++)
   {
	IF (L_ARRAY[I] != L_ARRAY2[I] * 2)
	{
	   KONEC = 1;
	   BREAK;
	}
   }

   IF (KONEC == 1)
   {
	PRINTF("NOT SAME\N");
   }ELSE{
        PRINTF("SAME\N");
   }
}

VOID TASK1(INT N)
{
    // ARRAY INITIALIZATION 
    FLOAT *L_ARRAY;
    IF ( CUDAMALLOCMANAGED( &L_ARRAY, N * SIZEOF( *L_ARRAY ) ) != CUDASUCCESS )
    {
        PRINTF( "UNABLE TO ALLOCATE UNIFIED MEMORY!\N" );
    }

    FLOAT *L_ARRAY2;
    IF (CUDAMALLOCMANAGED( &L_ARRAY2, N * SIZEOF(*L_ARRAY2)) != CUDASUCCESS)
    {
        PRINTF( "UNABLE TO ALLOCATE UNIFIED MEMORY!\N" );
    }
    FOR ( INT I = 0; I < N; I++ )
    {
        L_ARRAY[ I ] = ( FLOAT ) I;
    }
    FOR ( INT I = 0; I < N; I++ )
    {
        L_ARRAY2[ I ] = ( FLOAT)  I;
    }

    FLOAT *RESULT = NEW FLOAT[N];
    IF (CUDAMALLOCMANAGED( &RESULT, N * SIZEOF(*RESULT)) != CUDASUCCESS)
    {
        PRINTF( "UNABLE TO ALLOCATE UNIFIED MEMORY!\N" );
    }

    //PRINTARRAY(L_ARRAY, N);
    //PRINTARRAY(L_ARRAY2, N);

    FOR (INT I = 0; I< N;I++)
    {
        RESULT[I] = 0.0;
    }
    
    // FUNCTION CALLING FROM .CU FILE
    CU_RUN_SUM( L_ARRAY, L_ARRAY2, RESULT,  N, M_PI );
    
    CHECKARRAY(RESULT, L_ARRAY2, N);
    

    CUDAFREE( L_ARRAY );
    CUDAFREE( L_ARRAY2);
    CUDAFREE( RESULT );

}

VOID TASK2()
{
    CONST CHAR* SOURCE_FILE_NAME = "MAIN2_UNM.CPP";

    // OTEVRENI SOUBORU
    FILE* SOURCE_FILE = FOPEN(SOURCE_FILE_NAME, "R");
    IF (!SOURCE_FILE) {
        STD::CERR << "NUNABLE TO OPEN SOUCE FILE!!" << STD::ENDL;
    }

    // ZISKANI DELKY SOUBORU
    FSEEK(SOURCE_FILE, 0, SEEK_END);
    LONG FILE_SIZE = FTELL(SOURCE_FILE);
    FSEEK(SOURCE_FILE, 0, SEEK_SET);

    // ALOKACE PAMETI PRO NACTENI OBSAHU SOUBORU
    CHAR* BUFFER;
    IF (CUDAMALLOCMANAGED(&BUFFER, (FILE_SIZE + 1) * SIZEOF(FILE_SIZE)) != CUDASUCCESS)
    {
        PRINTF("UNABLE TO ALLOCATE UNIFIED MEMORY!\N");
    }
    
    // PRECTENI OBSAHU SOUBORU DO BUFFERU
    SIZE_T READ_BYTES = FREAD(BUFFER, 1, FILE_SIZE, SOURCE_FILE);
    BUFFER[READ_BYTES] = '\0';

    // UZAVRENI ZDROJOVEHO SOUBORU
    FCLOSE(SOURCE_FILE);
    // VOLANI CUDY
    CU_RUN_PREVOD(BUFFER, FILE_SIZE + 1);
    
    // ULOZENI OBSAHU DO VYSTUPNIHO SOUBORU
    STD::STRING SOURCE_CODE(BUFFER);
    FILE* OUTPUT_FILE = FOPEN("SOURCE_CODE.UP", "W");
    IF(!OUTPUT_FILE)
    {
	STD::CERR << "NEPODARILO SE OTEVRIT SOUBOR" << STD::ENDL;
    }
    FWRITE(BUFFER, 1, READ_BYTES, OUTPUT_FILE);
    FCLOSE(OUTPUT_FILE);
    // UVOLNENI PAMETI
   
    
    CUDAFREE( BUFFER );
}
VOID INITMATRIX(DOUBLE *MATRIX, INT ROWS, INT COLS) {
    FOR (INT I = 0; I < ROWS; ++I) {
        FOR (INT J = 0; J < COLS; ++J) {
            MATRIX[I * COLS + J] = RAND() % 10;
        }
    }
}
VOID INITMATRIXE(DOUBLE *MATRIX, INT ROWS, INT COLS) {
    FOR (INT I = 0; I < ROWS; ++I) {
        FOR (INT J = 0; J < COLS; ++J) {
            MATRIX[I * COLS + J] = 0;
        }
    }
}

VOID PRINTMATRIX(DOUBLE *MATRIX, INT ROWS, INT COLS) {
    FOR (INT I = 0; I < ROWS; ++I) {
        FOR (INT J = 0; J < COLS; ++J) {
            STD::COUT << MATRIX[I * COLS + J] << " ";
        }
        STD::COUT << STD::ENDL;
    }
}

VOID TRANSPOSEMATRIX(DOUBLE *SRC, DOUBLE *DST, INT ROWS, INT COLS) {
    FOR (INT I = 0; I < ROWS; ++I) {
        FOR (INT J = 0; J < COLS; ++J) {
            DST[J * ROWS + I] = SRC[I * COLS + J];
        }
    }
}


VOID TASK3(INT M){
    PRINTF("TASK3 %D\N",M);
    
    DOUBLE *MATICEA;
    DOUBLE *MATICEB;
    DOUBLE *MATICEC;
    DOUBLE *MATICEB_T;
    IF (CUDAMALLOCMANAGED(&MATICEA, (M * M) * SIZEOF(DOUBLE)) != CUDASUCCESS)
    {
        PRINTF("UNABLE TO ALLOCATE UNIFIED MEMORY!\N");
    }
    IF (CUDAMALLOCMANAGED(&MATICEB, (M * M) * SIZEOF(DOUBLE)) != CUDASUCCESS)
    {
        PRINTF("UNABLE TO ALLOCATE UNIFIED MEMORY!\N");
    }
    IF (CUDAMALLOCMANAGED(&MATICEC, (M * M) * SIZEOF(DOUBLE)) != CUDASUCCESS)
    {
        PRINTF("UNABLE TO ALLOCATE UNIFIED MEMORY!\N");
    }
    IF (CUDAMALLOCMANAGED(&MATICEB_T, (M * M) * SIZEOF(DOUBLE)) != CUDASUCCESS) {
        PRINTF("UNABLE TO ALLOCATE UNIFIED MEMORY!\N");
    }
    
    PRINTF("OK\N"); 
    INITMATRIX(MATICEA, M, M);
    INITMATRIX(MATICEB, M, M);

    TRANSPOSEMATRIX(MATICEB, MATICEB_T, M, M);

    
    INITMATRIXE(MATICEC, M, M);

    CU_RUN_MATICE(MATICEA, MATICEB_T, MATICEC, M);

    PRINTMATRIX(MATICEA, M,M);
    PRINTF("\N");
    PRINTMATRIX(MATICEB_T, M,M);
    
    PRINTF("\N\N");
    PRINTMATRIX(MATICEC, M,M);
    
    CUDAFREE(MATICEA);
    CUDAFREE(MATICEB);
    CUDAFREE(MATICEC);
}
// HODNOTA PRO DELKU POLE
#DEFINE N 100000000


// HODNATA PRO VELIKOST MATICE
#DEFINE M 1000

INT MAIN()
{
    // TASK 1 - 
    // DLE PRIKLADU CUDA2_UNM SI NAIMPLEMENTUJTE FUNKCI A KERNEL, KTERY PROVEDE SECTENI DVOU VEKTORU PRVKU FLOAT A VYSLEDEK SE VRATI VE TRETIM VEKTORU.
    // DELKA VEKTORU MINIMALNE 1000000 PRVKU. ZVOLTE SI PRVKY VEKTORU TAK, ABY JSTE NASLEDNE DOKAZALI SNADNO V PROGRAMU ZKONTROLOVAT, ZE VYSLEDEK JE SPRAVNE
    // NE ALE PRIMITIVNI ZADANI TYPU: VSECHNY PRVKY POLE JSOU 0 NEBO 1, NEBO VSECHNY STEJNE.
    STD::COUT << STD::ENDL<< "TASK 1 SECTENI DVOU POLI, IMPLEMENTOVANA I KONTROLA ZDALI VYSLEDEK JE SPRAVNY."<<STD::ENDL;
    TASK1(N);

    //TASK 2 -
    // NAPISTE SI FUNKCI A KERNEL, KTERY PREVEDE RETEZEC NA VELKA PISMENA. NACTETE SI SVUJ ZDROJOVY KOD *.CPP, PREVEDTE HO NA VELKA PISMENA A ULOZTE JAKO *.UP.
    // PRO PREVOD NA VELKA PISMENA SI PRO KERNEL PRIPRAVTE VHODNE POLE ZNAKU (KONVERZNI TABULKU), ABY KERNEL NEOBSAHOVAL PRO SAMOTNY PREVOD ZADNY IF.
    STD::COUT << STD::ENDL<< "TASK 2 PREVOD NA VELKE PISMENA, GENEROVANI SOUBORU SOURCE_CODE.UP"<<STD::ENDL;
    TASK2();
    STD::COUT << STD::ENDL<< "SOUBOR \"SOURCE_CODE.UP\" VYGENEROVAN."<<STD::ENDL;
    // TASK 3 -
    // NAPISTE SI FUNKCI A KERNEL PRO NASOBENI DVOU MATIC A VYSLEDEK SE ULOZI DO TRETI MATICE. ROZMER MATIC MINIMALNE 1000X1000 A TYP PRVKU DOUBLE. MATICE BUDE MIT
    // PEVNE DANOU VELIKOST A BUDE TAK TVORIT JEDEN SOUVISLY BLOK DAT. DRUHOU MATICI SI PRED NASOBENIM TRANSPONUJTE, ABY NASOBENI NEPROBIHALO STANDARDNE RADEK X 
    // SLOUPEC, ALE RADEK X RADEK. KERNEL BUDE OBSAHOVAT JEDINOU SMYCKU FOR PRO VYPOCET JEDNOHO PRVKU MATICE (VSECHNY KERNELY TAK BUDOU VYKONAVAT STEJNY KOD).
    // PRVKY V OBOU MATICICH SI PRIPRAVTE TAK, ABY SE NASLEDNE DALO SNADNO (AUTOMATICKY) ZKONTROLOVAT, ZE VYSLEDEK JE SPRAVNE. 
    // (NE NAPR. VSECHNY PRVKY MATICE 0 NEBO 1 A VE VYSLEDKU VSECHNY PRVKY STEJNE HODNOTY).
    STD::COUT << STD::ENDL<< "TASK 3 NASOBENI MATIC"<<STD::ENDL;
    TASK3(M);
    RETURN 0;
}